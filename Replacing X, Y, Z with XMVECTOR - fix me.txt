struct TIGER_POSITION {
	XMVECTOR	position = XMVectorSet(0, 0, -2, 0);
/*	float		X = 0;
	float		Y = 0;
	float		Z = 2;*/
	XMVECTOR	direction = XMVectorSet(0, 0, 0, 0);
/*	float		RX = 0;
	float		RY = 0;
	float		RZ = 0;*/
	float		speed = 2;
	XMVECTOR    initDir = XMVectorSet(0, 0, -2, 0);
};

void CALLBACK OnFrameMove( double fTime, float fElapsedTime, void* pUserContext )
{
	if (isLeftArrowDown) {
		XMVectorSetX(tiger->direction, XMVectorGetX(tiger->direction) - fElapsedTime * 3); // frame rate
	}
	if (isRightArrowDown) {
		XMVectorSetX(tiger->direction, XMVectorGetX(tiger->direction) + fElapsedTime * 3);	// independent.
	}
	if (isDownArrowDown) {
		XMVectorSetY(tiger->direction, XMVectorGetY(tiger->direction) - fElapsedTime * 3);
	}
	if (isUpArrowDown) {
		XMVectorSetY(tiger->direction, XMVectorGetY(tiger->direction) + fElapsedTime * 3);
	}
}



	//Calculate current direction
	XMMATRIX rotation = XMMatrixRotationRollPitchYaw(XMVectorGetY(tiger->direction), 
							XMVectorGetX(tiger->direction), 
							XMVectorGetZ(tiger->direction));
	XMVECTOR newDir = XMVector3TransformCoord(tiger->initDir, rotation);
	newDir = XMVector3Normalize(newDir);

	//Move tiger in that direction by the speed
	newDir *= tiger->speed * fElapsedTime;

	//**************************************************************************//
    // Initialize the view matrix.  What you do to the viewer matrix moves the  //
	// viewer, or course.														//
	//																			//
	// The viewer matrix is created every frame here, which looks silly as the	//
	// viewer never moves.  However in general your viewer does move.			//
	//**************************************************************************//
	XMVECTOR Eye;
	XMVECTOR At;
	XMVECTOR Up;
	
	if (!isTigerView) { //Base / 3rd "person" view
		Eye = XMVectorSet(0.0f, 1.0f, -10.0f, 0.0f);
		At = XMVectorSet(0.0f, 0.0f, 0.0f, 0.0f);
		Up = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);
	}
	else { //Follow the tiger
		Eye = XMVectorSet(XMVectorGetX(tiger->position), 
							XMVectorGetY(tiger->position) + 1.0f, 
							XMVectorGetZ(tiger->position) - 10.0f, 0.0f);
		Eye = XMVector3Normalize(Eye);
		At =  XMVectorSet(XMVectorGetX(tiger->direction), 
							XMVectorGetY(tiger->direction), 
							XMVectorGetZ(tiger->direction), 0.0f);
		At = XMVector3Normalize(At);
		Up =  XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);
		Up = XMVector3Normalize(Up);
	}

	XMMATRIX matView;
	matView = XMMatrixLookAtLH( Eye,	// The eye, or viewer's position.
								At,		// Th e look at point.
							    Up );	// Which way is up.

	//Update tiger position
	XMVectorSetX(tiger->position, XMVectorGetX(newDir));
	XMVectorSetY(tiger->position, XMVectorGetY(newDir));
	XMVectorSetZ(tiger->position, XMVectorGetZ(newDir));

	//******************************************************************//
	// Create the world matrix for the tiger: just a rotate around	    //
	// the Y axis of 45 degrees.  DirectX does all angles in radians,	//
	// hence the conversion.  And a translate.							//
	//******************************************************************//

	XMMATRIX matTigerTranslate = XMMatrixTranslation(XMVectorGetX(tiger->position), 
														XMVectorGetY(tiger->position),
														XMVectorGetZ(tiger->position));
	XMMATRIX matTigerScale     = XMMatrixScaling(10, 10, 10);
	XMMATRIX matTigerWorld     = rotation * matTigerTranslate * matTigerScale;
    
	XMMATRIX matWorldViewProjection = matTigerWorld * matView * matProjection;